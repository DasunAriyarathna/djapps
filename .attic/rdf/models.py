import datetime
from django.db import models
from django.contrib.auth.models import User

MAX_DATA_SIZE       =   256

class RDFDefaults:
    RDF_LITERAL_NODE        = 'L'
    RDF_URIREF_NODE         = 'U'
    RDF_BLANK_NODE          = 'B'
    RDF_VARIABLE_NODE       = 'V'
    RDF_QUOTEDGRAPH_NODE    = 'Q'

    NODE_TYPE_CHOICES = (
        (RDF_URIREF_NODE,       'URIRef'),
        (RDF_LITERAL_NODE,      'Literal'),
        (RDF_BLANK_NODE,        'BlankRDFNode'),
        (RDF_VARIABLE_NODE,     'Variable'),
        (RDF_QUOTEDGRAPH_NODE,  'QuotedRDFGraph'),
    )

    STATUS_ACTIVE           = 0
    STATUS_DELETED          = 1

# 
# Details of creation for any item.
#
class CreationDetail(models.Model):
    # 
    # The creator of the item, note that this is something only to identify
    # the username in the system.  This is NOT the actual user entity/item
    # itself.  There will need to be another Item associated with a
    # "Creator" or "CreatedBy" relationship if you want details about the
    # author of this entity.
    #
    # Same goes for the "Content" of this item.  Facts and Sources have
    # contents as little snippets, books will have entire texts as the
    # content, images will have binary files and so on, we will leave it
    # upto sparql to do all this processing and returning the appropriate
    # items
    #
    creator     = models.ForeignKey(User)

    # 
    # When it was created
    #
    created     = models.DateTimeField(default = datetime.datetime.today())

    # 
    # Status of the item.  What does this do?  nothing for now, but later
    # on, this can be used to flag what is happening to an item.  So we can
    # say an item is "Active", "BeingMoved", "Locked" and so on - the
    # different states can only be limited.
    #
    status      = models.IntegerField()

    def __unicode__(self):
        return u"User: %s, Date: %s, Status: %d" %  \
            (self.creator.username, self.created, self.status)

    def __str__(self):
        return "User: %s, Date: %s, Status: %d" %   \
            (self.creator.username, self.created, self.status)

    class Admin:
        pass

# 
# RDFNodes in the RDF RDFGraph
#
class RDFNode(models.Model):
    # 
    # The actual node data.
    #
    # The type of data is denoted below by nodeType.  Literals are easy to
    # store.  However, if this item is a URI, how can this be generated?
    # Is this generated by the user?
    #
    # Should this data be unique?  Many nodes can have the same value
    # literal - in which case should they all point to the same instance or
    # to different instances.
    #
    # Eg is there only "2" or many items with the value "2"?  So how would
    # a search happen for this item?
    #
    # For now we will make it unique.  The reason is that there will always
    # be only one instance of a constant.  If an item's value can change,
    # then it should really point to a blank node which will point to the
    # "2"
    #
    # This would also ensure less unnecessary data and speed up searches,
    # especially in cases like:
    #   find all living things that have "2" legs
    #
    # So we have to think in terms of pointers rather than values.  To
    # change the value of a variable, we are saying, change where it points
    # to rather than WHAT it is pointing to.
    #
    # Does this mean, we should be able to remove "literals"?  It is
    # possibel to remove nodes, but what happens if we have to remove a
    # node that is being used by a lot of items?  Should this be a cascaded
    # delete?
    #
    nodeData   = models.CharField(maxlength = 256)

    # 
    # The node type
    #
    nodeType    = models.CharField(maxlength = 1, choices=RDFDefaults.NODE_TYPE_CHOICES)
    # nodeType   = models.CharField(maxlength = 1)

    # 
    # Details about the node creation
    #
    creation    = models.ForeignKey(CreationDetail)

    def __unicode__(self):
        return u"Node ID: %s, Data: %s, Type: %s" % (str(self.id), self.nodeData, self.nodeType)

    def __str__(self):
        return "Node ID: %s, Data: %s, Type: %s" % (str(self.id), self.nodeData, self.nodeType)

    class Admin:
        pass

# 
# A property in an RDF graph.
# Properties in the RDF RDFGraph are edges between nodes.
#
class RDFProperty(models.Model):
    # 
    # The URIRef of the property.
    # A property cannot be anything else.
    #
    uri         = models.CharField(maxlength = MAX_DATA_SIZE, unique = True)

    # 
    # Creation details of the property
    #
    creation    = models.ForeignKey(CreationDetail)

    def __unicode__(self):
        return u"Property ID: %s, URI: %s" % (str(self.id), self.uri)

    def __str__(self):
        return "Property ID: %s, URI: %s" % (str(self.id), self.uri)

    class Admin:
        pass

# 
# A graph in rdf - it is a collection of nodes
# A certain node can belong to more than one graph
#
class RDFGraph(models.Model):
    # 
    # Name of the graph
    #
    name        =   models.CharField(maxlength = 128, unique = True)

    # 
    # The items that belong to this graph.  This ONLY contains 
    # RDFNode items, not the relationship items
    #
    nodes       =   models.ManyToManyField(RDFNode)

    # 
    # Creation details
    #
    creation    =   models.ForeignKey(CreationDetail)

    def __unicode__(self):
        return u"Graph ID: %s, Name: %s" % (str(self.id), self.name)

    def __str__(self):
        return "Graph ID: %s, Name: %s" % (str(self.id), self.name)

    class Admin:
        pass


# 
# A relationship between two items, the two items (subject and object) and
# the relationship (property) are also items themselves.
#
class RDFTuple(models.Model):
    subject     =   models.ForeignKey(RDFNode, related_name = 'subject')
    property    =   models.ForeignKey(RDFProperty, related_name = 'property')
    object      =   models.ForeignKey(RDFNode, related_name = 'object')

    # 
    # Creation details
    #
    creation    =   models.ForeignKey(CreationDetail)

    def __unicode__(self):
        return u"Tuple ID: %s, Subject ID/Data: (%d - %s), Property: %s, Object: %s" % \
            (str(self.id), self.subject.id, self.subject.nodeData, self.property.uri, self.object.nodeData)

    def __str__(self):
        return "Tuple ID: %s, Subject ID/Data: (%d - %s), Property: %s, Object: %s" % \
            (str(self.id), self.subject.id, self.subject.nodeData, self.property.uri, self.object.nodeData)

    class Admin:
        pass

class KeywordSearch(models.Model):
    statement   =   models.CharField(maxlength = 1024)
    keywords    =   models.ManyToManyField(RDFNode)
    created     =   models.DateTimeField()
    searchtype  =   models.CharField(maxlength = 256)

    class Admin:
        pass

class ItemSearchEntry(models.Model):
    node        =   models.ForeignKey(RDFNode)
    search      =   models.ForeignKey(KeywordSearch)
    relevance   =   models.FloatField(max_digits = 4, decimal_places = 2)

    class Admin:
        pass

